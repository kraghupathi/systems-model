#+TITLE:  Configuration Server
#+PROPERTY: session *scratch*
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org
#+options: ^:nil
 
* Introduction
  In this documentation, we call config-server as ansible server, configuration
  server and also node.
  
  This document describes the requirements, design and implementation of the
  configuration server.
  
  This configuration server plays a vital role in the cluster to complete the
  infrastructure. Since configuration server configures all other nodes in the
  cluster and configures itself as well, through multiple roles and tasks. A
  role is a specific set of configurations.

  It contains all the ansible-scripts to bring up the other nodes. The purpose
  of this server is to avoid manual configuration of nodes by team members. The
  mechanism ansible provides to configure other nodes is via ssh.
 
  The configuration server will be able to ssh to other servers and lab
  instances/containers using *key based authentication only* since public key of
  configuration server will be placed in all other servers/nodes,
  instances/containers and itself also. Password based authentication is not
  allowed to this node

  The services to register and de-register labs provided by the configuration
  server are also captured in the document.

** COMMENT Only from management ip machines, we will be able ssh to root account
of configuration server. Password based authentication is not allowed
to root user, only key based authentication is allowed from specific
ip machines.  

- Note  ::  In future we can have non-root(normal) user to
            ssh to configuration server only from management ip
            machines.

* Requirements
 The requirements of the config-server which differ from the generic
 requirements(specified in common-role) are mentioned here.

** Functional Requirements
   1. Configuration server will configure all the nodes in the cluster
      including itself and ensures that the configuration is
      consistent.
   2. Configuration server has only one `root' user.
   3. Only authorized VLEAD members can login as 'root' user from IIIT
      IP range or management ip machines using key based
      authentication only.
   4. Provide service to register and de-register labs. 

** Security Requirements
   The Configuration server accepts incoming connections on port 22
   *only* from IIIT IP range or management ip machines.
* Design
** Configuration
  The following network diagram represents how the configuration
  server is connecting to other nodes such as reverse proxy, DNS,
  router etc.

  #+CAPTION:  Configuration Server Design Diagram
  #+LABEL:  fig-config-diagram
  [[./diagrams/config-server-network-diagram.png]]
   
  Configuration server is one of the many other nodes in the cluster.
  Only IIIT IP range and management ip machines are allowed to ssh to
  root account of the configuration server.

  The design of the firewall rules ensures that this server is
  accessible only via port 22.  

  SSH access to the node is allowed only via *key-based
  authentication*. Password based authentication is not allowed to the
  root user. SSH configuration, fail2ban and locking root user
  password are taken care by common role. For more tasks which are
  done by common role to the node are described in [[./common.org][common role]].
  
  The Configuration server can be reached via ICMP (ping) requests.
  Public key of the configuration server will be placed in every
  instance/container. So the configuration server will be able to
  configure all other nodes, instances/containers and as well as
  itself by running the ansible scripts. These ansible scripts are
  described and implemented at the [[Implementation][implementation]] section.

** Services
The design of the service provided by the configuration server are described
below.
  #+CAPTION:  Configuration Server Services Design Diagram
  #+LABEL:  fig-config-services-diagram
  [[./diagrams/hooks1.png]]

*** Description
- Hosting of a Lab ::
Hosting a lab comprises of deployment and registration of lab. 

- Deployment of a Lab :: 
Instantiating a new node in the cluster, deploying a lab on the node.

- Registration ::
A lab is said to be registered by the service when the necessary configuration
changes in the system servers such as DNS, reverseproxy, nagios are done and lab
is accessible from external world.

- De registration ::
A lab is said to be de-registered by the service when the various entries are
removed from the servers and lab is no longer accessible.

- Work Flow of the Service ::
To register or deregister a lab, ADS invokes the service provided by the
configuration server over SSH. Service first writes the input arguments passed
by the ADS into a data file (.txt). Then the data is appended in the yaml
file. Ansible playbook is then run to reconfigure the whole cluster again.

Work Flow of the service is described in following diagram
#+CAPTION:  Hooks Service Work Flow Diagram
  #+LABEL:  fig-config-services-diagram
  [[./diagrams/hooks-workflow.png]]

** System Configuration files Summary

The following table gives the information about services and their configuration
files. Other configuration files are updated in common role.
|-----------+-----------------------------------+---------------------------|
| *Service* | *Configuration file*              | *Description*             |
|-----------+-----------------------------------+---------------------------|
| firewall  | =/etc/sysconfig/iptables/=        | configuration server Role |
|-----------+-----------------------------------+---------------------------|
| IP        | =/etc/sysconfig/network-scripts/= | amazon console            |
|-----------+-----------------------------------+---------------------------|

#+TBLFM: $2=/etc/sysconfig/network-scripts

* Implementation
** Configuration
  The implementation of the configuration server is done in the following steps.
  - Note :: In this implementation, variables are used in various places using
            "{}". Values of these variables are defined in [[common_vars.org][common_vars role]].

*** Structure of the scripts
   The implementation of this system is in terms of a collection of ansible
   scripts that configures the machine. The scripts are organized as follows:

#+BEGIN_EXAMPLE
|-- services
|   |-- hosting_service.py
|   |-- program.py
|   `-- config.py
|-- config_server.yml
|-- roles
|   |-- config_server
|   |   |-- handlers
|   |   |   `-- main.yml
|   |   |-- tasks
|   |   |   |-- main.yml
|   |   `-- templates
|   |       `-- iptables

#+END_EXAMPLE

   Here =config_server.yml= file configures the configuration server with the
   config_server and all other roles. The other roles are:
    - [[./common.org][common]]
    - rsyslog_client
    - ossec_client
    - nagios_client
    - config_server

   =roles/config_server/handlers/main.yml= file defines various handlers which
   are only executed in case a task notifies them. Handlers are described in
   details at [[Handlers][handlers]].  The handlers are called only when tasks are called as
   part of the config_server role. Various templates and files are being used
   during task execution for creating necessary configuration files.

   =roles/config_server/tasks/main.yml= file consist of various tasks which are
   needed for setting up config_server. These tasks are implemented and
   described [[Tasks][here]].
   
   =roles/config_server/templates/iptables= template file consist of
   various firewall rules in order to configure this node securely by
   running the [[Apply firewall rules to Configuration server][task]]. This template uses various variables and these
   variable values are defined in common_vars role. This template is
   created at [[Firewall rules]] section and you can see the description
   each firewall.

*** Tasks
**** Firewall rules
    Rules which are specific to configuration server are described [[Firewall rules specific to config_server][below]].
    Description of each firewall rule of this configuration server and
    which are common across all the systems are described in [[.common.org][common role]].

#+BEGIN_SRC yaml :tangle roles/config_server/templates/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#Allow internal process to process communication over loopback interface
# Accept loopback connections
-A INPUT -i lo -d 127.0.0.0/8 -j ACCEPT
#Rate limit new connections to 20 new connections per 30 seconds
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --set
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --rcheck --seconds 30 --hitcount 20 -m limit --limit 2/min -j LOG --log-prefix "new_limit_"
-A INPUT ! -p udp -m state --state NEW -m recent --name ssh_limit --rcheck --seconds 30 --hitcount 20 -j DROP
#Accept ICMP ping requests at limited rate
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 60/minute --limit-burst 120 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/minute --limit-burst 2 -j LOG
-A INPUT -p icmp --icmp-type echo-request -j DROP

#Allow ongoing connections
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
{% for ip in nagios_server_ips %}
-A INPUT -p tcp -m tcp -s {{ip}} --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from management IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in management_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from ansible_server IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in ansible_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from rsnapshot_server IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in rsnapshot_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from ads server IP. This is used to invoke hooks service from ads server.
-A INPUT -m state --state NEW -s {{ads_ip}} -p tcp -m tcp --dport 22 -j ACCEPT

#Allow incoming NRPE queries for nagios from nagios servers
-A INPUT -m state --state NEW -p tcp -m tcp --dport 5666 -j ACCEPT
#Log all other "blocked_input_" attempts with rate limiting
-A INPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_input_"

#Reply with proper ICMP error message and reject the connection
-A INPUT -j REJECT --reject-with icmp-host-prohibited
#Do not allow any packet to be forwarded
-A FORWARD -j REJECT --reject-with icmp-host-prohibited

##Output rules
#Allow outgoing connections to localhost
-A OUTPUT -s 127.0.0.0/8 -o lo -j ACCEPT

#Allow ongoing connections
-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

#Allow DNS queries
-A OUTPUT -p udp -m udp --dport 53 -j ACCEPT

#Allow server to send emails.  Required for sending logwatch emails
-A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT

# 80 and 443 OUTPUT is needed for yum update and to install packages
-A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT

#Allow outgoing ping requests
-A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT

#Allow outgoing connections to rsyslog server
-A OUTPUT -p udp -m udp --dport 514 -j ACCEPT

#Allow outgoing connections to OSSEC server
-A OUTPUT -p udp -m udp --dport 1514 -j ACCEPT
#Log all other "blocked_output_" attempts
-A OUTPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_output_"

#Reply with proper ICMP error message and reject the connection
-A OUTPUT -j REJECT --reject-with icmp-host-prohibited
COMMIT
#+END_SRC
**** Firewall rules specific to config_server

***** SSH access from management ips
     The following firewall rule accepts incoming connections on tcp
     port 22 only from management ips

#+BEGIN_SRC example
{% for item in management_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#+END_SRC

***** SSH access from ansible server ips
     The following firewall rule accepts incoming connections on tcp
     port 22 only from ansible server ips

#+BEGIN_SRC example
{% for item in ansible_server_ips %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#+END_SRC

**** Installing ansible and bind-utils
    Install latest ansible package to setup the configuration server
    itself and to run the ansible scripts to configure the other nodes
    in the cluster.

#+BEGIN_SRC yaml :tangle roles/config_server/tasks/main.yml
---
- name: installing ansible
  yum: name=ansible state=present
- name: Installing bind-utils
  yum: name=bind-utils state=present
#+END_SRC
**** Apply firewall rules to Configuration server
    Firewall rules are applied by following steps:
    1) Copy the =iptables= template to the configuration server.
    2) Restart iptables service if the configuration file is modified
       and apply the configuration.

#+BEGIN_SRC yaml :tangle roles/config_server/tasks/main.yml
- name: Copy iptables configuration file for configuration server
  template: src=iptables dest=/etc/sysconfig/iptables mode=600 owner=root group=root
  notify: restart iptables
#+END_SRC

**** Set PATH environment
Set environment variable "PATH" so the service can be invoked from
anywhere independent of the same working directory where file is
present. Service is located at =/root/systems-model/build/cluster=
directory.

#+BEGIN_SRC yaml :tangle roles/config_server/tasks/main.yml
- name: set environment variable
  lineinfile: dest=/etc/environment regexp=^PATH= line=PATH=/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/root/systems-model/build/cluster
#+END_SRC

**** Make service executable
Hooks service is run via hosting_service program. To be able to invoke
this service as a command we will make this program executable.
#+BEGIN_SRC yaml :tangle roles/config_server/tasks/main.yml
- name: make service program executable
  shell: chmod +x hosting_service

- name: make hooks.sh executable
  shell: chmod +x hooks.sh
#+END_SRC

**** Handlers
   Restart the iptables service if configuration file of iptables is
   modified. These handlers are called only when tasks notifies to
   start service.

#+BEGIN_SRC yaml :tangle roles/config_server/handlers/main.yaml 
---
- name: restart iptables
  service: name=iptables state=restarted
#+END_SRC

**** Main configuration file
   The configuration server is managed with all other roles. The
   implementation is done in terms of defining suitable scripts for
   each role.  The top level script is =build/code/config_server.yml=

#+BEGIN_SRC yaml :tangle config_server.yaml
---
- name: This file configures ansible server
  hosts: ansible_server
  remote_user: root

  vars:
    i_ans: yes
    host_name: "ansible.{{prefix}}vlabs.ac.in"

  roles:
    - common
    - config_server
    - rsyslog_client
#    - ossec_client
    - nagios_client
    - rsnapshot_client

#+END_SRC

** Services
Configuration server provides service to register and deregister a lab in a
cluster. ADS invokes service exposed by the configuration server over *ssh* as
follows:

#+BEGIN_EXAMPLE
ssh vlead@ansible.vlabs.ac.in service <register/deregister> <hostname> <ipaddress>
#+END_EXAMPLE

For the above service to work, ADS's public-key is to be placed in
Configuration server's vlead user's authorized keys with ssh forced
command enabled to make sure that only register/deregister service is
called by ADS.

- SSH Forced Command ::
   Forced command is used if the users can only connect through ssh.
   Essentially, whenever the user connects through ssh with a certain key or
   a certain username, you force him to execute a command (or a script)
   you determined in the .ssh/authorized_keys. Other commands issued by the users
   will be ignored.

#+BEGIN_EXAMPLE
 # in .ssh/authorized_keys 
 command="hooks.sh",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa public_key
#+END_EXAMPLE

*Note:*  you need these options to secure a forced command: 
"no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty"
 
- Input Arguments ::
The program takes the following three arguments as input:
1. A keyword - (register or deregister)
2. Hostname
3. Ipaddress of the lab

The arguments passed to the service are saved in a data file in the following
format:

#+BEGIN_EXAMPLE
lab1 10.100.1.10
lab2 10.100.1.12
#+END_EXAMPLE

Service then reads the data from the data file and updates the entries in the
yml files of various server.
*** Hooks bash script
This script is invoked via ssh forced command, when hook service is invoked from
ads server. Script splits the arguments passed into variables and calls
hosting_service. It also does logging of when and at what time the command was
called.
#+BEGIN_SRC yaml :tangle hooks.sh
#!/bin/sh

IFS=' ' read -a myarray <<< "$SSH_ORIGINAL_COMMAND"

arg2=${myarray[1]}
arg3=${myarray[2]}
arg4=${myarray[3]}

date=`date`
echo "$date::$SSH_ORIGINAL_COMMAND" >> log.txt
sudo chmod 777 /root/systems-model/build/cluster/roles/common_vars/vars/main.yml

hosting_service $arg2 $arg3 $arg4

sudo chmod 644 /root/systems-model/build/cluster/roles/common_vars/vars/main.yml

if [[ "$?"=="0" ]]
then
echo "Status::Success::$?" >> log.txt
else
echo "Status::Fail::$?" >> log.txt
fi
#+END_SRC

*** Service Program
Following program updates the entries in the data file with the values passed by
the ADS service.

**** Main Function
The main function provides help to the user about the functionality of
the service. Its main job is to register the lab if the argument
passed is 'register' and deregister the lab if the argument passed is
'deregister'. It updates the yml configuration file. Error code is
thrown if the ads service tries to register existing lab or tries to
deregister non-existent lab.

#+BEGIN_SRC python :tangle hosting_service :eval no :padline no
#!/usr/bin/env python

import sys
from config import *
from hosting_program import *
from subprocess import call

def main(argv):

    if (len(argv) == 1 and argv[0] == '--help'):
        print serviceHelp
        return

    if (len(argv) < 3):
        print serviceHelp
        return

    if (str(argv[0]) == "register"):
        returnCode = register(argv[1], argv[2])
        if (returnCode != code['regError']):
            readLabFile = open(labPath, "r")
            labData = readLabFile.readlines()
            readLabFile.close()
            update_reg(labData)
            f = open("/dev/null","w")
            call(["sudo", "ansible-playbook", "-i", hostsPath, yaml['priv-dns']], stdout=f)
            call(["sudo", "ansible-playbook", "-i", hostsPath, yaml['pub-dns']], stdout=f)
            call(["sudo", "ansible-playbook", "-i", hostsPath, yaml['rp']], stdout=f)
            f.close()
        else:
            sys.exit(123)

    elif (str(argv[0]) == "deregister"):
        returnCode = deregister(argv[1], argv[2])
        if (returnCode != code['deregError']):
            update_dereg(argv[1], argv[2])
            f = open("/dev/null","w")
            call(["sudo", "ansible-playbook", "-i", hostsPath, yaml['priv-dns']], stdout=f)
            call(["sudo", "ansible-playbook", "-i", hostsPath, yaml['pub-dns']], stdout=f)
            call(["sudo", "ansible-playbook", "-i", hostsPath, yaml['rp']], stdout=f)
            f.close()
        else:
            sys.exit(123)

    else:
        returnCode = code['failcall']
        sys.exit(123)

    return returnCode
#+END_SRC

**** Register
Register function finds the entry of the lab to be registered in the
data file. If the entry is not present then it appends the new entry
in the data file. But if the entry is already present then it throws
an error.

#+BEGIN_SRC python :tangle hosting_service :eval no
def register(hostname, ip):

    index, entries = findEntry(hostname, ip)
    if (index >= 0):
        return code['regError']

    else:
        hostnameIP = "%s %s\n" %(hostname, ip)
        entries.append(hostnameIP)
        writeData(entries)
        return code['regSuccess']
#+END_SRC

**** Deregister
Deregister function finds the entry of the lab to be deregistered in
the data file. If the entry is present then it deletes the entry from
the data file. But if the entry is not present then it throws an
error.

#+BEGIN_SRC python :tangle hosting_service :eval no
def deregister(hostname, ip):

    index, entries = findEntry(hostname, ip)

    if (index >= 0):
        del entries[index]
        writeData(entries)
        return code['deregSuccess']
    else:
        return code['deregError']
#+END_SRC

**** Findentry
Findentry function finds the entry of a lab in the data file.  If the
entry exist function returns the index of the entry, if the entry is
not found it returns -1. Existent entries are also returned.

#+BEGIN_SRC python :tangle hosting_service :eval no
def findEntry(hostname, ip):

    labData = []
    try:
        readLabFile = open(labPath, "r")
        hostnameIP = "%s %s\n" %(hostname, ip)

        labData = readLabFile.readlines()
        readLabFile.close()

        index = labData.index(hostnameIP)
        return index, labData
    except:
        return -1, labData
#+END_SRC

**** WriteData
This function writes the lab entries in the data file.

#+BEGIN_SRC python :tangle hosting_service :eval no
def writeData(configData):
    writeLabFile = open(labPath, "w")
    for item in configData:
        writeLabFile.write(item)
    writeLabFile.close()
    return
#+END_SRC

**** Main function condition
#+BEGIN_SRC python :tangle hosting_service :eval no
if __name__ == "__main__":
    main(sys.argv[1:])
#+END_SRC

*** Update Program
Following program reads the values from data file and updates the yml file.

**** Define Variables
1. *delimiters* - Defines the delimiters used by various sections in the yml files
2. *fileLocation* - Defines the file location of the various yml files where
   variables are defined. 
3. *labPath* - Define lab data file path
4. *code* - Defines various error and success code
5. *yaml* - Defines ansible playbook files path for various servers
6. *hostsPath* - Defines path to hosts file used by ansible-playbook
7. *serviceHelp* - Docstring of the service to provide help to users

#+BEGIN_SRC python :tangle config.py :eval no
delimiters = {}
delimiters['priv-dns'] = ["#Priv-DNS_START\n", "#Priv-DNS_END\n"]
delimiters['pub-dns'] = ["#Pub-DNS_START\n", "#Pub-DNS_END\n"]
delimiters['reverseproxy'] = ["#DOMAIN_START\n", "#DOMAIN_END\n"]
delimiters['awstats'] = ["#AWSTATS_START\n", "#AWSTATS_END\n"]
delimiters['nagios'] = ["#Nagios_START\n", "#Nagios_END\n"]

fileLocation = {}
fileLocation['priv-dns'] = '/root/systems-model/build/cluster/roles/common_vars/vars/main.yml'
fileLocation['pub-dns'] = '/root/systems-model/build/cluster/roles/common_vars/vars/main.yml'
fileLocation['nagios'] = '/root/systems-model/build/cluster/roles/common_vars/vars/main.yml'
fileLocation['reverseproxy'] = '/root/systems-model/build/cluster/roles/common_vars/vars/main.yml'
fileLocation['awstats'] = '/root/systems-model/build/cluster/roles/common_vars/vars/main.yml'

labPath = "/home/vlead/lab.txt"

code = {}
code['regError'] = "Code 1: Error - Lab is already registered"
code['deregError'] = "Code 1: Error - Lab is not registered"
code['regSuccess'] = "Code 0: Success - Lab is now registered"
code['deregSuccess'] = "Code 0: Success - Lab is now deregistered"
code['failcall'] = "Code 1: Error - Service not invoked with proper arguments"

yaml = {}
yaml['rp'] = '/root/systems-model/build/cluster/reverseproxy_server.yaml'
yaml['priv-dns'] = '/root/systems-model/build/cluster/private_dns.yaml'
yaml['pub-dns'] = '/root/systems-model/build/cluster/public_dns.yaml'

hostsPath = '/root/systems-model/build/cluster/hosts'
serviceHelp = '''
Configuration server provides service to register and deregister a lab in a
cluster. ADS invokes service exposed by the configuration server over *ssh* as
follows:

"ssh vlead@ansible.vlabs.ac.in service <register/deregister> <hostname> <ipaddress>"

Input Arguments:
The program takes the following three arguments as input:
1. A keyword - (register or deregister)
2. Hostname
3. Ipaddress of the lab

To know more type: "pydoc hosting_service"
'''
#+END_SRC

**** Update Register
This function constructs data in the proper format for dns,
reverseproxy, awstats and nagios from the argument passed to the
function. It then calls *append_data* function to append data in the
yml file.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
from config import *

def update_reg(labData):

    entry = {}
    entry['dns'] = []
    entry['reverseproxy'] = []
#    entries['nagios'] = []
    entry['awstats'] = []
    for labs in labData:
        labs = labs.strip("\n")
        hostname, ip = labs.split(" ")
        line = hostname + " " + ip
        entry['dns'].append(dns_format(line))
        entry['reverseproxy'].append(reverseproxy_format(line))
     #   entry['nagios'].append(nagios_format(line))
        entry['awstats'].append(awstats_format(line))

    for key in entry:
        append_to_data(key, entry[key])
    return
#+END_SRC

**** Update Deregister
This function constructs pattern that is to be searched in the yaml
file. It then deletes the entry from yaml file.

#+begin_src python :tangle hosting_program.py :eval no
def update_dereg(hostname, ip):

    pattern = {}
    pattern['reverseproxy'] = """  - {domain: "%s.{{prefix}}virtual-labs.ac.in", alias: "%s.{{prefix}}vlabs.ac.in" }\n""" %(hostname, hostname)
    pattern['awstats'] = """  - %s."{{prefix}}"virtual-labs.ac.in\n""" %(hostname)
    pattern['dns'] = """  - { hostname: %s, ip: %s }\n""" %(hostname, ip)

    servers = ['dns', 'reverseproxy', 'awstats']

    for key in servers:
        ymlFile = open(fileLocation[key], "r")
        ymlData = ymlFile.readlines()
        del ymlData[ymlData.index(pattern[key])]
        ymlFile.close()
        ymlFile = open(fileLocation[key], "w")
        for lines in ymlData:
            ymlFile.write(lines)
        ymlFile.close()

    return
#+end_src
**** Rsnapshot
Rsnapshot uses *awstats-domain* variables so there is nothing explicitly to be
done for this.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def rsnapshot_format(line):
    ''' 
	    There is no need to do anything explicit for the lab rsnapshot-server.
	    It reads entries from awstats-domains variables
    '''    

    return
#+END_SRC

**** Nagios
Create data in the proper format to be updated in the nagios variable section.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def nagios_format(line):
    splitLine = line.split()
    labidHostname = '    %s: { hostname: "%s.{{prefix}}vlabs.ac.in", group: lab }\n' %(splitLine[0], splitLine[0])
    return labidHostname
#+END_SRC

**** DNS
Create data in the proper format to be updated in the dns variable section.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def dns_format(line):    
    splitLine = line.split()
    entry = "  - { hostname: %s, ip: %s }\n" %(splitLine[0], splitLine[1])
    return entry
#+END_SRC

**** Awstats
Create data in the proper format to be updated in the awstats variable section.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def awstats_format(line):  
    splitLine = line.split()
    fqdn = splitLine[0] + '."{{prefix}}"virtual-labs.ac.in'
    entry = '  - %s\n' %(fqdn)
    return entry
#+END_SRC

**** Reverseproxy
Create data in the proper format to be updated in the reverseproxy variable
section.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def reverseproxy_format(line):
    splitLine = line.split()
    fqdn = splitLine[0] + '.{{prefix}}virtual-labs.ac.in'
    alias = splitLine[0] + '.{{prefix}}vlabs.ac.in'
    entry = '  - {domain: "%s", alias: "%s" }\n' %(fqdn, alias)

    return entry
#+END_SRC

**** Append to data
Data in the yml file is structured in the following format.

#+BEGIN_EXAMPLE
variable_name:
#Start_Section
<entry>
<entry>
<entry>
#End_Section
#+END_EXAMPLE

This function reads the yml file and finds the data section which is to be
updated using the *start* and *end* delimiters for various servers. Then update
the data with the new entries and writes back to the yml file.

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def append_to_data(key, data):

    ymlFile = open(fileLocation[key], "r")

    ymlData = ymlFile.readlines()

    for entry in data:
        try:
            del ymlData[ymlData.index(entry)]
        except:
            continue

    startIndex = ymlData.index(delimiters[key][0])
    endIndex = ymlData.index(delimiters[key][1])

    newYmlData = ymlData[0:startIndex + 1] + data + ymlData[startIndex+1:]

    ymlFile.close()

    newYmlFile = open(fileLocation[key], "w")

    for lines in newYmlData:
       newYmlFile.write(lines)

    newYmlFile.close()

    return
#+END_SRC

**** Nagios entry
Flow of the function is as follows:

- 1 :: Read data from the yml file
- 2 :: Find start and end of the "Nagios" entry section
- 3 :: Read values from input data file
- 4 :: Save all the new entries in a variable
- 5 :: Combine existing data and new entries
- 6 :: Write all the entries in the yml file

#+BEGIN_SRC python :tangle hosting_program.py :eval no
def nagios(inputFile, outputFile):
    labFile = open(inputFile, "r")
    ymlFile = open(outputFile, "r")

    ymlData = ymlFile.readlines()

    nagiosStartIndex = ymlData.index("#Nagios_START\n")
    nagiosEndIndex = ymlData.index("#Nagios_END\n")
    nagiosNewEntries = []

    for line in labFile.readlines():
        splitLine = line.split()
        labidHostname = '    %s: { hostname: "%s.{{prefix}}vlabs.ac.in", group: lab }\n' %(splitLine[0], splitLine[0])
        nagiosNewEntries.append(labidHostname)

    delimeter = list("#Nagios_END\n")
    newYmlData = ymlData[0:nagiosStartIndex + 2] + nagiosNewEntries + delimeter + ymlData[nagiosEndIndex+1:]

    labFile.close()
    ymlFile.close()

    newYmlFile = open(outputFile, "w")

    for lines in newYmlData:
        newYmlFile.write(lines)

    newYmlFile.close()

    return

#+END_SRC

**** Rsnapshot entry
Rsnapshot yml files reads data from "awstats_domain" variable. There is no
separate entries for rsnapshot.
#+BEGIN_SRC python :tangle hosting_program.py :eval no
def rsnapshot(inputFile, outputFile):
    ''' 
            There is no need to do anything explicit for the lab rsnapshot-server.
            It reads entries from awstats-domains variables
    '''

    return

#+END_SRC

* Release
Next release will consist of ads hooks. ADS hooks impose services that can be
invoked by ADS to register a lab in the cluster. 

* Test Cases
** Test case ID :: SSH access using AWS KeyPair
*** Objective
    Test to check if SSH is allowed only from IIIT network for the user
    root and denied from other ips using AWS KeyPair
*** Apparatus
    1. Security KeyPair
    2. A workstation with IIIT ips 
    3. A workstation with unknown ip 
    4. Configuration server 
*** Procedure
    1. Assume you are inside the IIIT network.
    2. Create a VM and generate new security KeyPair using AWS console
    3. Place/copy the KeyPair into ssh-tunnel container.
    4. Give 400 permission to that KeyPair and
    5. ssh to config_server from workstation 
*** Experiments
**** SSH to the config_server from management ips/ IIIT ips
    Since configuration server is created using AWS console, KeyPair
    of this server is generated during creation of the VM. So the
    private KeyPair is placed in "ssh-tunnel" container on base2. From
    "ssh-tunnel", only VLEAD members (who have ssh access to
    ssh-tunnel and sudo permissions to root account) can ssh to
    configuration server only from IIIT network.  ssh to configuration
    server using the below command:
    #+BEGIN_SRC example
    ssh -i test.pem root@54.56.34.231
    #+END_SRC
***** Expected result
   #+BEGIN_EXAMPLE
    Last login: ---Details of last login---
    [root@localhost ~]$
   #+END_EXAMPLE
***** Result
    #+BEGIN_EXAMPLE
    Last login: Mon Mar 16 02:28:31 2015 from ssh-tunnel.vlabs.ac.in
    [root@config-server~]$
    #+END_EXAMPLE
**** SSH to config_server from workstation with unknown ip
    Suppose a workstation with unknown ip(other than IIIT network ip)
    and it has KeyPair, then try ssh to configuration server from that
    workstation using bellow command:

    #+BEGIN_SRC example 
    unknown-machine$ ssh -i test.pem root@54.56.34.231
    #+END_SRC
***** Result
    #+BEGIN_SRC example
    Permission denied....
    #+END_SRC
*** Observation 
    Configuration server is able accept ssh connection only from
    IIIT/management ips and not from any other machines with unknown
    ips.
*** Result 
    Test is passed. Firewall rules and ssh are configured and applied
    properly. 
*** Conclusion
  Iptables and ssh are configured and applied appropriately. Configuration
  server is able accept ssh connections only from IIIT/management IPs and
  not from unknown ips.

** Test case ID :: SSH access using RSA key
*** Objective
    Test to check if SSH is allowed only from IIIT network for the user
    root and denied from other ips using workstation's RSA key
*** Apparatus
    1. RSA key
    2. A workstation1 with IIIT ips 
    3. A workstation2 with unknown ip 
    4. Configuration server 
*** Procedure
    1. Assume you are inside the IIIT network.
    2. Create a container and generate ssh key using the following command
       #+BEGIN_SRC example
       ssh-keygen -t rsa 
       #+END_SRC
       Provide the passphrase if you need. Else press RETURN for no passphrase.
    3. Place/copy the id_rsa.pub of workstation into configuration
       server's authorized_keys.
    4. SSH to configuration server from workstation.
*** Experiments
**** SSH to the config_server from IIIT ips/management ips
    From "workstation1", only VLEAD members (who have ssh access to
    workstation and sudo permissions to root account) can ssh to
    configuration server only from IIIT network.  ssh to configuration
    server using the bellow command:
    #+BEGIN_SRC example
    workstation1$ssh root@54.56.34.231
    #+END_SRC
***** Expected result
   #+BEGIN_EXAMPLE
    Last login: ---Details of last login---
    [root@localhost ~]$
   #+END_EXAMPLE
***** Result
    #+BEGIN_EXAMPLE
    Last login: Mon Mar 16 02:28:31 2015 from workstation1
    [root@config-server~]$
    #+END_EXAMPLE
**** SSH to config_server from workstation2 with unknown ip
    ssh to configuration server from workstation2 which has unknown
    ip(other than IIIT network ip) using bellow command
    #+BEGIN_SRC example 
    workstation2$ ssh root@54.56.34.231
    #+END_SRC
***** Result
    #+BEGIN_SRC example
    Permission denied....
    #+END_SRC
*** Observation 
    Configuration server is able to accept ssh connection only from
    IIIT/management ips and not from any other machines with
    unknown ips.
*** Result
    Test is passed. configuration is working fine
*** Conclusion
  Iptables are configured and applied appropriately. Configuration
  server is able accept ssh connections only from IIIT/management IPs
  and not from unknown ips.

** Test case ID :: Invoke hosting service over SSH
*** Objective
    Test to check if the hosting service is being invoked from the ads server
    over SSH.
*** Apparatus
    1. Configuration server
    2. ADS Server
*** Procedure
    1. Login to ads machine.
    2. Invoke hosting service from ads machine as follows via SSH
#+BEGIN_EXAMPLE
ssh ansible@ansible.vlabs.ac.in service register test-lab <ipaddress>
#+END_EXAMPLE
   3. Check the return status of the ssh command using following command. If the
      command returns '0' then it is executed successfully else the command has
      thrown some error.
#+BEGIN_EXAMPLE
echo $?
#+END_EXAMPLE
*** Observation
    Configuration server is able to accept request to host lab via ssh from ads
    server.
*** Result
    Test is passed. Hosting service is working fine
*** Conclusion
  Hosting service program is developed properly and is configured properly.

** Unit Tests
Following program tests the functionality of each function of the hosting
service module.

#+BEGIN_SRC python :tangle testing_program.py :eval no
import unittest
from hosting_program import *
from hosting_service import *

def findIndex(path, entry):
    readFile = open(path, "r")

    fileData = readFile.readlines()
    readFile.close()
    try:
        index = fileData.index(entry)
    except:
        index = -1
    
    return index

def writetoFile(hostnameIP):

    writeLabFile = open(labPath, "w")
    writeLabFile.write(hostnameIP)
    writeLabFile.close()
    return

def deleteFile():
    with open(labPath, "w"):
        pass
    return

class TestUpdateMethods(unittest.TestCase):
    
    def test_findEntry(self):
	hostname = "lab10"
	IP = "10.1.1.1"
	hostnameIP = "%s %s\n" %(hostname, IP)
	
	writetoFile(hostnameIP)

	index, entries = findEntry(hostname, IP)
        deleteFile()
        self.assertTrue(index >= 0)
	return

    def test_writeData(self):
	hostname = "lab10"
	IP = "10.1.1.1"
	hostnameIP = "%s %s\n" %(hostname, IP)
	data = [hostnameIP]
	writeData(data)

        index = findIndex(labPath, hostnameIP)
        
        deleteFile()

        self.assertTrue(index >= 0)
	return
    
    def test_register_with_error(self):
        hostname = "lab10"
	IP = "10.1.1.1"
	hostnameIP = "%s %s\n" %(hostname, IP)
	
	writetoFile(hostnameIP)
	
	returncode = register(hostname, IP)
	deleteFile()
        self.assertEqual(returncode, code['regError'])
	return
	

    def test_register_with_success(self):
	hostname = "lab10"
	IP = "10.1.1.1"
	hostnameIP = "%s %s\n" %(hostname, IP)
	returncode = register(hostname, IP)
        deleteFile()
	self.assertEqual(returncode, code['regSuccess'])
	return

    def test_nagios_format(self):
	line = 'lab10	10.1.1.1'
	function_return = nagios_format(line)
	splitLine = line.split()
	entry = '    %s: { hostname: "%s.{{prefix}}vlabs.ac.in", group: lab }\n' %(splitLine[0], splitLine[0])
	self.assertEqual(entry, function_return)
	return

    def test_dns_format(self):
	line = 'lab10	10.1.1.1'
	function_return = dns_format(line)
	splitLine = line.split()
	entry = " - { hostname: %s, ip: %s }\n" %(splitLine[0], splitLine[1])
	self.assertEqual(entry, function_return)
	return

    def test_awstats_format(self):
	line = 'lab10	10.1.1.1'
	function_return = awstats_format(line)
	splitLine = line.split()
	fqdn = splitLine[0] + ".virtual-labs.ac.in"
	entry = '  - %s\n' %(fqdn)
	self.assertEqual(entry, function_return)
	return

    def test_reverseproxy_format(self):
	line = 'lab10	10.1.1.1'
	function_return = reverseproxy_format(line)
	splitLine = line.split()
	fqdn = splitLine[0] + ".virtual-labs.ac.in"
	alias = splitLine[0] + ".vlabs.ac.in"
	entry = '  - {domain: "%s", alias: "%s" }\n' %(fqdn, alias)
	self.assertEqual(entry, function_return)
        return


    def test_append_to_data(self):
	line = 'lab10	10.1.1.1'
	splitLine = line.split()
        key = 'dns'
        entry = " - { hostname: %s, ip: %s }\n" %(splitLine[0], splitLine[1])
	data = [entry]
        append_to_data(key, data)
        
	index = findIndex(fileLocation[key], entry)
	
        self.assertTrue(index >= 0)

	return

    def test_update(self):
	line = 'lab10	10.1.1.1'
	splitLine = line.split()
	writetoFile(line)
	update()
        key = 'dns'
        entry = " - { hostname: %s, ip: %s }\n" %(splitLine[0], splitLine[1])

	index = findIndex(fileLocation[key], entry)
        self.assertTrue(index >= 0)
	return


if __name__ == '__main__':
    unittest.main()

#+END_SRC
